ACTUAL

JMH generates one class per method that is annotated with @Benchmark but that is transparent to JMH users.


OTHER





- Benchmark classes should NOT be final


STATE
- State classes should NOT be final 
-The State annotation only supports public classes.
Instances are automatically injected into your @Benchmark method calls as arguments

The @State annotation is useful in the context of concurrent benchmarks. In our case, we simply hint to JMH that x and y are thread-scoped.
Field "x" is declared within the class not having @State annotation. This can result in unspecified behavior, and prohibited.
Lifecycle and parameter injection. In simple cases, class fields can hold the benchmark state values.
In more-elaborate contexts, it is better to extract those into separate @State annotated classes. Benchmark methods can then have parameters of the type of these state classes, and JMH arranges instances injection. A state class can also have its own lifecycle with a setup and a tear-down method. We can also specify whether a state holds for the whole benchmark, for one trial, or for one invocation.

State objects naturally encapsulate the state on which benchmark is working on. The Scope of state object defines to which extent it is shared among the worker threads.

State objects are usually injected into Benchmark methods as arguments, and JMH takes care of their instantiation and sharing. State objects may also be injected into Setup and TearDown methods of other State objects to get the staged initialization.

Run programmatically - 
Finally, we can also provide a main method to this benchmark using the JMH builder API, which mimics the command-line arguments that can be given to the self-contained JAR executable. See Listing 19.

public static void main(String... args) throws RunnerException {
  Options opts = new OptionsBuilder()
    .include(".*.GoodBench.*")
    .warmupIterations(20)
    .measurementIterations(5)
    .measurementTime(TimeValue.milliseconds(3000))
    .jvmArgsPrepend("-server")
    .forks(3)
    .build();
  new Runner(opts).run();}
  
Devising Concurrent Benchmarks
-FINAL part of http://www.oracle.com/technetwork/articles/java/architect-benchmarking-2266277.html

  
  Given the two baselines, we clearly see the effects of dead-code elimination and constant folding. The only meaningful measurement of distance() is when the value is being consumed by JMH and parameters are passed through field values. All other cases converge to either the performance of returning a constant double or an empty void-returning method.
  
  
*SET OF PARAMS* - Demo?  
Running a test with a set of parameters

In many situations you need to test your code with several sets of parameters. Luckily, JMH does not force you to write N test methods if you need to test N sets of parameters. Or, to be more precise, JMH will help you if your test parameters are primitives, primitive wrappers or Strings.

All you need to do is:

    Define a @State object
    Define all your parameters fields in it
    Annotate each of these fields with @Param annotation

@Param annotation expects an array of String arguments. These strings will be converted to the field type before any @Setup method invocations. Nevertheless, JMH documentation claims that these field values may not be accessible in @Setup methods.

JMH will use an outer product of all @Param fields. So, if you have 2 parameters on the first field and 5 parameters on the second field, your test will be executed 2 * 5 * Forks times. 
*SETS OF PARAMS*

*THREAD GROUPS test - readers outnumber writers* - Demo?
Thread groups – non uniform multithreading

We have already mentioned that @State(Scope.Benchmark) annotation could be used to test the case of multithreaded access to the state object. The degree of concurrency will be set by the number of threads which should be used for testing.

You may also need to define the non-uniform access to your state object – for example to test the “readers-writers” scenario where the number of readers is usually higher than the number of writers. JMH uses the notion of thread groups for this case.

In order to setup a group of tests, you need:

    Mark all your test methods with @Group(name) annotation, providing the same string name for all tests in a group (otherwise these tests will be run independently – no warning will be given!).
    Annotate each of your tests with @GroupThreads(threadsNumber) annotation, specifying a number of threads which will run the given method.

JMH will start a sum of all your @GroupThreads for the given group and will run all tests in a group concurrently in the same trial. The results will be given for the group and for each method independently. 
*THREAD GROUPS*

